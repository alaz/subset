# Extractor

Every `Field[T]` provides an extractor from $dbobject$ to `T`. It
depends on the availability of `ValueReader[T]` type class. See
[values]($appBaseUrl$/Serializer.html) for details.

```scala
val f = "f".fieldOf[Int]

dbObject match {
  case f(value) => 
  case smth => logger warn "cannot parse %s".format(smth)
}
```

## Extractor Failures

Since `ValueReader` only knows how to extract from $dbobject$ values,
it cannot know how to process the absence of a field. Thus, for a
field declaration like the above, the inability of `ValueReader` to
extract `Int` will be indistinguishable from the fact there is no
field "f" in the `DBObject`. What choices do we have?

We may declare the field as `Option[Int]`:

```scala
val f = "f".fieldOf[Option[Int]]
```

In this case, the field extractor will always succeed if there is a
field "f" (of any kind), but it will return `Some` if `ValueReader`
has successfully extracted the value and `None` if it could
not. Anyway the extractor will fail if there is no such key at all.

## Default Value

We may also declare the field as having a default value:

```scala
val f = "f".fieldOf[Option[Int]].withDefault(None)
```

The extractor will always succeed and it will return the default value
if there is no such key or if `ValueReader` could not extract the value.

* * *
