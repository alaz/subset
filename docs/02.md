# Why Subset

[10gen](http://www.10gen.com/) (the company behind [MongoDB](http://www.mongodb.org/)) officialy
releases a [Java driver](http://www.mongodb.org/display/DOCS/Java+Language+Center)
and supports the development of ["Casbah"](https://github.com/mongodb/casbah), Scala driver
for MongoDB. There are also a number of other Scala libraries for MongoDB, most of them are
mentioned at this [page](http://www.mongodb.org/display/DOCS/Scala+Language+Center). There is
also ["Salat"](https://github.com/novus/salat), which aims at serializing of
Scala case classes only.

Given this range of libraries, [**Subset**](https://github.com/osinka/subset) has the following
design goals (very different from the previous Osinka's project of this kind,
[mongo-scala-driver](https://github.com/osinka/mongo-scala-driver))

* It is not a replacement for database querying and modification APIs, original **mongo-java-driver**
  and **Casbah** are great at that. So if one needs to query/modify MongoDB database, he or she must
  utilize another library. However **Subset** plays nice with both Java driver or **Casbah**. If
  there is no need to access the database, **Subset** still relies on the Java driver to perform
  BSON encoding/decoding.

* It has a library of value serializers/deserializers for common Java and Scala
  types (e.g. Scala's `Symbol`, `Traversable[T]`, `Option[T]`, etc.). **Subset**
  does not utilize reflection, but selects the proper serialization mechanism
  via Scala's "implicits". This library usage is optional, it's possible to make
  use of **Casbah** support instead.

* **Subset** tries to be typed, but never at the cost of extra complexity.

You are still allowed to shoot your foot, e.g.

> assuming you have a field `f` of type `Int`

```scala
val f = "f".fieldOf[Int]
```

> though the field update operations accept the same type

```scala
val updateOp = f.set("str") // compiler error!
val updateOp = f.set(10)    // ok
```

> you are still allowed to join it with something logically different, e.g. a
> query

```scala
val wrongJoin = updateOp ~ (f === 3)
```

> This compiles fine, produces a valid `DBObject`, but MongoDB will complain
> if you'll try to use it in `update` method.

The reason is that **Subset** produces as compatible objects as possible. Both
update operation and query condition are [*Lens*]($siteBaseUrl$/Lens.html)
objects and they are compatible with plain $dbobject$ by design: you can always modify
an existing $dbobject$.

* * *
